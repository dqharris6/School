\documentclass[12pt]{report}
\usepackage{amsmath,amsthm,latexsym,paralist}
\usepackage[document]{ragged2e}

\theoremstyle{definition}
\newtheorem{problem}{Problem}

\begin{document}
\vspace*{-15mm}
\begin{center}
{\large
					CSCE 221 - Homework Set 3 \\
					Due 2/15/2015, 11:59 PM}
\end{center}

\begin{problem} 		R-6.4 (5 points)
\end{problem}			
					( 0  1  2  3 ) -- Represents initial vector. \\
					( 4  1  2  3 ) \\
					( 3  1  2  3 ) \\
					( 2  1  2  3 ) \\
					( 2  1  1  3 ) \\
					( 2  5  1  3 ) \\
					( 2  6  1  3 ) \\
					( 2  6  1  7 ) \\
					( 8  6  1  7 )

\begin{problem}			R-6.14 (5 points)
\end{problem}
					To implement a more effective solution to this, we would add a simple if() statement that 					compares current index to half the size of the array. If the index is greater than the 						halfway point, start from the end, and if it is less, start from the beginning. \\
					
\begin{problem}			R-6.17 (5 points)
\end{problem}
				\begin{tabular}{| l | l | l |}
					\hline
					Operation & Time & Pseudo-code \\ 
					\hline
					size, empty 			& O(1) 	& size.of.array() and is.array.empty()	\\
					atIndex, indexOf 		& O(1)	& go to given index, return value stored there \\
					begin, end				& O(1)	& array(0) or array(size-1)	 \\
					*p, ++p, --p			& O(1)	& array(position*position), array(position++), \\											&		& array(position--)  \\
					insertFront, InsertBack	& O(1)	& all indexes ++, insert at (0) or simply size++ \\										&		&	and insert at array(size-1) \\
					insert, erase			& O(n)	& go to array(position), all indexes greater than \\										&		&	that add one to position, insert at new blank \\										&		&	space. Or, go to array(position), all indexes \\										&		&	greater than that subtract one from position.\\
					\hline
				\end{tabular}
					
\begin{problem}			R-6.18 (5 points)
\end{problem}
					First, define a recursive function that will determine if the sequence S of n elements 						contains an element k. There will be 3 input arguments: the sequence S, an Iterator 						start that holds the index of the first element in the sequence, and the actual element k. 					Run this only until the element is read in the sequence. Use an integer value to prevent 					an infinite loop. If the first element contains the value, print it out. If not, increment the 					start iterator and repeat until it is found, or every element has been checked. \\
					The size of this function is the size of local variables and the size of all parameters. The 					size of the variables here is 2 bytes, and the size of parameters = 4 bytes (iterator and 					integer). Total, this equals 6 bytes.
					
\begin{problem}			R-6.19 (5 points)
\end{problem}
					makeFirst() moves an element of sequence S to the first element in the sequence, no 					matter where it starts. To do so, change the prev and next of the nodes present before 					and after the element at the given position. No loops can be used, it must stay at O(1) 					time. First, create a node object to point to the node stored at the given position. Also, 					make node objects to point to the elements stored before and after the given position. 					Store the first pointer's next and the second pointer's next to be the same value, and 					the first previous and the third previous likewise. This will make the second and the 						third point to each other. Finally, make the third pointer's next to point to the beginning 					of the list, and the previous null. This will make the given value the first in the list.
					
\begin{problem}			C-6.12 (10 points)
\end{problem}
					In this implementation, we need to keep a variable for capacity and for size. Also, keep 					indexFirst and indexLast. Initially, all of the listed variables (except capacity) are set to 					0. \\
					The first of our functions, addFirst() will handle overflow (if it occurs), and set the 						indexFirst value to itself-1, assuming it is already greater than 0. Finally, it will increment 					the size by 1. \\
					Next, removeFirst() will set each index in the array to one less than its current, which 					will throw a range error when the index 0 is set to -1. Upon catching this, this value will 					be simply deleted. \\
					addLast() will handle overflow, change the capacity, and increment the size by 1 before 					inserting a given value into the array at position size()-1. \\
					removeLast() simply goes to the position size()-1, and increments it by -1, virtually 						removing it. \\
					Finally, get(i) checks to see if the list is empty, and returns the value stored at i							+indexFirst+1, and changes the capacity. 
					
\goodbreak
\end{document}


